[Скачайте проект](https://ulearn.me/Exercise/StudentZip?courseId=BasicProgramming&slideId=40d232f1-c280-44cd-83f7-7ec526407d62)

В файле AccountingModel.cs создайте класс AccountingModel, унаследованный от ModelBase, со следующими свойствами

* double Price (должно быть не меньше 0)
* int NightsCount (должно быть больше 0)
* double Discount (скидка. Ограничений нет)
* double Total (должно быть больше нуля)

Дополнительное ограничение целостности: `Total = Price * NightsCount * (1-Discount/100)`.

Все поля должны иметь сеттеры. При установке Price, NightsCount и Discount должна соответствующим образом устанавливаться Total, при установке Total - соответствующим образом меняться Discount. В случае установки значения, нарушающего условия целостности, необходимо выкидывать ArgumentException.

При изменении значения любого свойства необходимо дополнительно сигнализировать об этом с помощью вызова метода Notify, передавая ему имя изменяемого свойства. Здесь можно воспользоваться ключевым словом nameof.

FYI. Ситуация, когда свойства вот так взаимозависимы и при этом каждое имеет сеттер, довольно редка. В норме, Total бы имело только геттер. Однако, классы такого вида тоже встречаются - как модели-представления в WPF. Если вы изучите класс окна, описанный в MainWindow.xaml и MainWindow.cs, вы увидите, что там нет кода для обновления полей или выделения поля с ошибочным вводом. Вместо этого, там устанавливается связь между полями графического интерфейса и свойствами модели, а вся логика реализуется внутри модели. Такой подход называется MVVM.

PS. WPF не работает и не может работать на не-Windows компьютерах. В этом случае, вам не удастся увидеть, как именно работает MVVM-связка, но вы можете написать требуемый класс, создав новый проект.
